function dice_score = retinal_segmentation_pipeline(img_path, mask_path, visualize)
    % 1. Load training image and its manual mask
    img = imread(img_path); 
    manual_mask = logical(imread(mask_path));
    
    % 2. Preprocess image

    % Only keep the green channel
    green = img(:,:,2); 
    
    
    % Create a mask to ignore the black camera border so it is not detected
    % as a vessel
    fov_mask = green > 30;
    fov_mask = imfill(fov_mask, 'holes');
    fov_mask = imerode(fov_mask, strel('disk', 5));
    
    % Invert the image
    green_inv = imcomplement(green);
    % We use slightly gentler CLAHE to avoid boosting background noise
    preprocessed = adapthisteq(green_inv, 'NumTiles', [8 8], 'ClipLimit', 0.01);
    
    % 3. Frangi Vesselness Filter
    % We scan 1 to 3 to catch the main trunks too
    scales = [1, 2, 3]; 
    vesselness = zeros(size(preprocessed));
    
    for sigma = scales
        Iv = FrangiFilter2D(preprocessed, sigma);
        vesselness = max(vesselness, Iv);
    end
    
    % --- APPLY MASK ---
    % Zero out everything outside the retina
    vesselness = vesselness .* double(fov_mask);

    % 4. Post-processing: HYSTERESIS THRESHOLDING
    % Now that the border noise is gone, we can trust lower thresholds!
    t_low = 0.06;   % Very sensitive (catches thin capillaries)
    t_high = 0.12;  % Strict (catches main trunks)
    
    marker = vesselness > t_high;
    mask = vesselness > t_low;
    
    % "Reconstruct" keeps faint 'mask' pixels ONLY if they connect to 'marker'
    % This grows the vessels naturally without thickening them.
    binary_mask = imreconstruct(marker, mask);
    
    % Clean up tiny detached specks
    binary_mask = bwareaopen(binary_mask, 50);

    % 5. Evaluation
    dice_score = dice(binary_mask, manual_mask);
    fprintf('Final Dice Score: %.4f\n', dice_score);

    if visualize
        % 6. Comprehensive Visualization
        figure('Name', 'Pipeline Steps', 'NumberTitle', 'off', 'Color', 'w');
        
        % Row 1: Inputs & Preprocessing
        subplot(2, 3, 1); 
        imshow(img); 
        title('1. Original Image');
        
        subplot(2, 3, 2); 
        imshow(manual_mask); 
        title('2. Manual Ground Truth');
    
        subplot(2, 3, 3)
        imshow(preprocessed)
        title('3. Preprocessed Image (with CLAHE)')
    
        % Row 2: Processing & Result
        subplot(2, 3, 4); 
        imshow(vesselness, []); 
        colormap(gca, 'jet');
        title('4. Frangi Vesselness (Heatmap)');
        
        subplot(2, 3, 5); 
        imshow(binary_mask); 
        title('5. Final Binary Segmentation');
        
        subplot(2, 3, 6); 
        imshow(labeloverlay(img, binary_mask, 'Transparency', 0.5)); 
        title(['6. Overlay (Dice: ' num2str(d, '%.3f') ')']);
    end

    % save the binary segmentation to /results with its number

    imwrite(binary_mask, 'results/binary_segmentation.png');
end

function V = FrangiFilter2D(I, sigma)
    I = double(I);
    siz = round(3*sigma);
    [x,y] = meshgrid(-siz:siz, -siz:siz);
    
    % Gaussian
    G = exp(-(x.^2 + y.^2)/(2*sigma^2));
    G = G / sum(G(:));
    
    % Derivatives
    Gxx = (x.^2 - sigma^2) ./ (sigma^4) .* G;
    Gyy = (y.^2 - sigma^2) ./ (sigma^4) .* G;
    Gxy = (x.*y) ./ (sigma^4) .* G;
    
    Dxx = imfilter(I, Gxx, 'replicate');
    Dyy = imfilter(I, Gyy, 'replicate');
    Dxy = imfilter(I, Gxy, 'replicate');
    
    % Eigenvalues
    tmp = sqrt((Dxx - Dyy).^2 + 4*Dxy.^2);
    lambda1 = (Dxx + Dyy + tmp) / 2;
    lambda2 = (Dxx + Dyy - tmp) / 2;
    
    % Sort by magnitude
    mu1 = lambda1; mu2 = lambda2;
    check = abs(lambda1) > abs(lambda2);
    mu1(check) = lambda2(check);
    mu2(check) = lambda1(check);
    lambda1 = mu1; lambda2 = mu2;
    
    beta = 0.5;
    c = 15;
    
    % Tiny fix: added epsilon (eps) to prevent division by zero
    Rb = (lambda1 ./ (lambda2 + eps)).^2;
    S = lambda1.^2 + lambda2.^2;
    
    V = exp(-Rb / (2*beta^2)) .* (1 - exp(-S / (2*c^2)));
    V(lambda2 > 0) = 0;
    V = (V - min(V(:))) / (max(V(:)) - min(V(:)));
end